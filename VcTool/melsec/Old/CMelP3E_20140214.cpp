//================================================================================================
//	FileName	:CMelP3E.h
//	Class		:CMelsecP3E
// 				:Melsec プロトコル3E形式通信(QnA互換3Eフレーム)
//	作成日		:2007.02.17 coba
//================================================================================================
#include <stdio.h>
#include <conio.h>
#include "CMelP3E.h"

//========================================================================================================
//	CMelsecP3E::CMelsecP3E(void)
//	引数　：なし
//	返値　：
//　機能　：コンストラクタ。デフォルトサイズでデータバッファを作成
//========================================================================================================
CMelsecP3E::CMelsecP3E(void)
{
	m_fOpen=FALSE;
}

//========================================================================================================
//	CMelsecP3E::~CMelsecP3E()
//	デストラクタ
//	引数　：なし
//	返値　：
//　機能　：
//========================================================================================================
CMelsecP3E::~CMelsecP3E()
{
	WSACleanup();
}

//========================================================================================================
//	int CMelsecP3E::Init(int portNo,int baudrate,int databit,int stopbit,int parity,int wait);
//	type　：private
//　機能　：WinSock初期化
//========================================================================================================
BOOL CMelsecP3E::Init(void)
{
	// ｵｰﾌﾟﾝ中はOK
	if( m_fOpen ) return(TRUE);

  	WSADATA			WSAData;

	// ソケット初期化
  	if(WSAStartup( MAKEWORD(2,2), &WSAData)) return(-1);


	m_fOpen=TRUE;

	return(TRUE);
}


//========================================================================================================
//	int CMelsecP3E::P3ERead( char* ipaddr,unsigned short port,char* buf,int bufsize,int devtype,char* devaddr, short counts)
//	type　：public
//　機能　：プロトコル3E形式でデバイスデータをブロック受信
//	引数１：ターゲットのIPアドレス
//	引数２：ターゲットのUDPポート番号
//	引数３：受信バッファ
//	引数４：受信バッファサイズ
//	引数５：デバイスの種類(0=ワードデバイス、1=ビットデバイス)
//	引数５：読み出し先頭アドレス(8桁)
//	引数６：受信ブロック数(max256)
//========================================================================================================
int CMelsecP3E::P3ERead( char* ipaddr,unsigned short port,char* buf,int bufsize,int devtype,char* devaddr, short counts)
{

	// 送信バッファ
	char send[5120];
	int ret;

	// 未オープンエラー
	if( m_fOpen == FALSE ) return(-1);
	if( counts <0 || counts > 960 ) return(-2);

	// ｱﾄﾞﾚｽ(デバイスコード(2)+先頭デバイス(6))
	if( strlen(devaddr) !=8) return(-3);

	// IPアドレス
	if( INADDR_NONE == inet_addr(ipaddr) ) return(-4);

	// ポート番号
	if(port <1024 || port >65535) return(-5);

	memset( send, 0, sizeof(send) );

	// ①固定部
	// サブヘッダ"5000"+NW番号"00"+PC番号"FF"+要求先Unit#"03FF"+要求局番"00"
	strcpy( send,"500000FF03FF00");

	// ②送信データ長を算出する=読み出しなので固定長(監視タイマ～読み出し点数)
	sprintf( &send[strlen(send)],"%04X",P3E_FIX_DATALEN);


	// ③CPU監視タイマ(4)+コマンド(4)+サブコマンド(4)
	if( devtype==DEV_WORD)
		strcat( send,"001004010000");	// ワードデバイス
	else 
		strcat( send,"001004010001");	// ビットデバイス

	// ④読み出しｱﾄﾞﾚｽ(8)
	strcat( send,devaddr);

	// ⑤読み出し点数
	sprintf( &send[strlen(send)],"%04X",counts);
	// 送信する
	ret=UdpSend(ipaddr,port,send,strlen(send),buf,bufsize);

	return(ret);
}

//========================================================================================================
//	int CMelsecP3E::P3EWrite(char* ipaddr,unsigned short port,int devtype,char* devaddr, short counts, char* data)
//	type　：public
//　機能　：プロトコル3E形式でデバイスデータをブロック送信
//	引数１：ターゲットのIPアドレス
//	引数２：ターゲットのUDPポート番号
//	引数３：受信バッファ
//	引数４：受信バッファサイズ
//	引数５：デバイスの種類(0=ワードデバイス、1=ビットデバイス)
//	引数５：書き込み先頭アドレス(8桁)
//	引数６：送信ブロック数(max256)
//	引数７：書き込みデータ
//========================================================================================================
int CMelsecP3E::P3EWrite(char* ipaddr,unsigned short port,int devtype,char* devaddr, short counts, char* data)
{
	// 送信バッファ
	char send[5120];
	int ret;
	char buf[40+1];

	// 未オープンエラー
	if( m_fOpen == FALSE ) return(-1);
	if( counts <0 || counts > 960 ) return(-2);

	// ｱﾄﾞﾚｽ(デバイスコード(2)+先頭デバイス(6))
	if( strlen(devaddr) !=8) return(-3);

	// IPアドレス
	if( INADDR_NONE == inet_addr(ipaddr) ) return(-4);

	// ポート番号
	if(port <1024 || port >65535) return(-5);

	// 送信データ長
	if( devtype==DEV_WORD){
		if( (short)strlen(data) !=counts*4) return(-6);
	}
	else{
		if( (short)strlen(data) !=counts) return(-7);
	}
	memset( send, 0, sizeof(send) );

	// ①固定部
	// サブヘッダ"5000"+NW番号"00"+PC番号"FF"+要求先Unit#"03FF"+要求局番"00"
	strcpy( send,"500000FF03FF00");


	// ワードデバイス
	if( devtype==DEV_WORD){
		// ②送信データ長を算出する=(固定:監視タイマ～読み出し点数)+デバイス点数×4(バイト)
		sprintf( &send[strlen(send)],"%04X",P3E_FIX_DATALEN+counts*4);
		// ③CPU監視タイマ(4)+コマンド(4)+サブコマンド(4)
		strcat( send,"001014010000");	// ワードデバイス
	}
	// ビットデバイス
	else{
		// ②送信データ長を算出する=(固定:監視タイマ～読み出し点数)+デバイス点数
		sprintf( &send[strlen(send)],"%04X",P3E_FIX_DATALEN+counts);
		// ③CPU監視タイマ(4)+コマンド(4)+サブコマンド(4)
		strcat( send,"001014010001");	// ビットデバイス
	}
	// ④読み出しｱﾄﾞﾚｽ(8)
	strcat( send,devaddr);

	// ⑤読み出し点数
	sprintf( &send[strlen(send)],"%04X",counts);

	// ⑥送信データ
	if( devtype==DEV_WORD)
		memcpy( &send[strlen(send)],data,counts*4);
	else
		memcpy( &send[strlen(send)],data,counts);


	// 送信する
	ret=UdpSend(ipaddr,port,send,strlen(send),buf,sizeof(buf));

	return(ret);
}

//========================================================================================================
//	int CMelsecP3E::UdpSend( char* ipaddr,unsigned short port,char* data,int size,char* rcv,int rsize)
//	type　：private
//　機能　：UDP送受信
//	引数１：ターゲットのIPアドレス
//	引数２：ターゲットのUDPポート番号
//	引数３：送信データ
//	引数４：送信データサイズ
//	引数５：受信バッファ
//	引数６：受信バッファサイズ
//	戻り値：0=OK,0未満=ネットワークエラー、1=受信データエラー
//========================================================================================================
int CMelsecP3E::UdpSend( char* ipaddr,unsigned short port,char* data,int size,char* rcv,int rsize)
{
	SOCKET fSocket;
	WSAEVENT fEvent;
	//DWORD		cEvents;		//hEventsに含まれるイベントハンドルの数
	unsigned long laddr;
	WSABUF		wsBuf;		//WSABUF構造体配列
	DWORD		dwBufferCount;	//lpwsBufの示す配列に入っているWSABUF構造体の数
	DWORD		cnt;//送信バイト数を受け取るDWORD変数へのポインタ
	DWORD		dwFlags;		//送信方法を制御するビットマスク
	struct sockaddr_in	addr;
	int ret;
	WSANETWORKEVENTS events;
	int			iFromlen;//lpToの示すsockaddr構造体の長さを指定する整数
	char rbuf[4096];

	// IPｱﾄﾞﾚｽ変換(to 32bit)
	if( INADDR_NONE ==( laddr=inet_addr(ipaddr)) ) return(-101);

	fSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
//	fSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
	if (fSocket == INVALID_SOCKET){
		printf("socket()Err"); 
		return(-102);
	}
	fEvent = WSACreateEvent();
	if(fEvent == WSA_INVALID_EVENT){
		printf("\nWSACreateEvent()Err: %d\n", fEvent);
		closesocket(fSocket);
		return(-103);
	}

	ret = WSAEventSelect(fSocket,fEvent,FD_READ);
	if(ret == SOCKET_ERROR){
		printf("\nWSAEventSelect()Err: %d\n", ret);
		WSACloseEvent(fEvent);
		closesocket(fSocket);
		return(-104);
	}

	// 送信データ作成
	wsBuf.len=size;
	wsBuf.buf=data;
	dwBufferCount=1;
	dwFlags=MSG_DONTROUTE;//MSG_PARTIAL;

	memset(&addr, 0, sizeof(addr));
	addr.sin_family			= AF_INET;
	addr.sin_addr.s_addr	= laddr;
	addr.sin_port			= htons(port);

	// 送信
	ret=WSASendTo(fSocket,&wsBuf,dwBufferCount, &cnt,dwFlags,
					(LPSOCKADDR)&addr,sizeof(addr),NULL,NULL);
	if (ret == SOCKET_ERROR){
		WSACloseEvent(fEvent);
		closesocket(fSocket);
		return(-105);
	}

	// 受信待ち
	ret = WSAWaitForMultipleEvents(1,&fEvent,TRUE,10000,TRUE);
	if(ret == WSA_WAIT_TIMEOUT){
		WSACloseEvent(fEvent);
		closesocket(fSocket);
		return(-106);
	}

	ret = WSAEnumNetworkEvents(fSocket,fEvent,&events);
	if(ret == SOCKET_ERROR){
		WSACloseEvent(fEvent);
		closesocket(fSocket);
		return(-107);
	}

	// 受信イベント以外
	if((events.lNetworkEvents & FD_READ)==0){
		WSACloseEvent(fEvent);
		closesocket(fSocket);
		return(-108);
	}

	// 受信する
	//printf("Event Err FD=%d\n",FD_READ);
	memset( rbuf,0,sizeof(rbuf));
	wsBuf.len=sizeof(rbuf);
	wsBuf.buf=rbuf;
	dwBufferCount=1;
	dwFlags=0;//MSG_PEEK;//MSG_PARTIAL;
	memset(&addr, 0, sizeof(addr));
	iFromlen=sizeof(addr);

	ret=WSARecvFrom(fSocket,&wsBuf,dwBufferCount, &cnt,&dwFlags,
							(LPSOCKADDR)&addr, &iFromlen,NULL,NULL);


	WSACloseEvent(fEvent);
	closesocket(fSocket);

	// 終了コードをチェック(先頭から18バイト)
	if( memcmp( rbuf+18,"0000",4)){
		printf("\nrcv=%s",rbuf);
		// 終了コードを出力して終了
		memcpy( rcv,rbuf+18,4);
		return(1);
	}

	// 受信データ長(先頭から14バイト目)、終了コード(4バイト)を含んでいるので引く
	ret=this->htoi( rbuf+14,4)-4;

	// 受信データコピー
	if(ret>0){
		memset( rcv,0,rsize);
		memcpy( rcv, rbuf+22, ret> rsize ? rsize:ret);
	}

	return(0);
}

//========================================================================================================
//	int CMelsecP3E::Str2Mel(char* buf, unsigned int bufsize, char* str)
//	機能　：文字列を、Melsec送信形式に変換する
//			ex) "A1234"->"31413433"
//	引数１：出力バッファ
//	引数２：バッファサイズ（変換元データ長の２倍+1は必要）
//	引数３：変換元文字列データ(NULL-terminated)
//	返値　：0=OK
//========================================================================================================
int CMelsecP3E::Str2Mel(char* buf, unsigned int bufsize, char* str)
{
	unsigned int i,len;
	char txt[10];

	len = strlen(str);
	if( len*2 >= bufsize ) return(-1);

	memset( buf, 0, bufsize );

	for( i=0;i<len;i++){
		// 上下を入れ替える
		if( i+1==len )
			wsprintf( txt,"00");
		else
			wsprintf( txt,"%02X",(unsigned char)str[i+1]);	// 2011.03.11 coba
//			wsprintf( txt,"%02X",str[i+1]);
		memcpy( &buf[i*2], txt, 2 );

		wsprintf( txt,"%02X",(unsigned char)str[i]);		// 2011.03.11 coba
//		wsprintf( txt,"%02X",str[i]);
		i++;
		memcpy( &buf[i*2], txt, 2 );
	}

	return(0);

}

//========================================================================================================
//	unsigned char CMelsecP3E::htoi( char *hexstr , short len )
//	機能　：16進（文字列２文字のみ）を整数値(unsigned char型)に変換する
//	引数　：変換元データ格納ポインタ
//	返値　：変換後データ
//========================================================================================================
int CMelsecP3E::Mel2Str(char* buf, unsigned int bufsize, char* melstr)
{
	unsigned int i,len;

	len = strlen(melstr);
	if( bufsize<=len/2 ) return(-1);

	memset( buf, 0, bufsize );

	for( i=0;i<len;i+=2){
		// 上下を入れ替える
		if( i+2>=len )
			buf[strlen(buf)]=0x20;
		else
			buf[strlen(buf)]=(char)htoi( &melstr[i+2],2);

		buf[strlen(buf)]=(char)htoi( &melstr[i],2);
		i+=2;
	}
	return(0);
}

//========================================================================================================
//	unsigned char CMelsecP3E::htoi( char *hexstr , short len )
//	機能　：16進（文字列２文字のみ）を整数値(unsigned char型)に変換する
//	引数　：変換元データ格納ポインタ
//	返値　：変換後データ
//========================================================================================================
unsigned short CMelsecP3E::htoi( char *hexstr , short len )
{
	unsigned short ret = 0;
	short i;

	if( len > 4 ) return 0;
	for( i = 0 ; i < len ; i++ ){
		ret *= 16;
		if( hexstr[i] < 'A' ) ret += hexstr[i] - '0';
		else
		if( hexstr[i] < 'a' ) ret += hexstr[i] - 'A'+10;
		else
			ret += hexstr[i] - 'a'+10;
	}
	return(ret);
}


BOOL CMelsecP3E::ULChg( char* buf )
{
	char tmp[8];

	if( strlen(buf)<8 )
		return FALSE;

	memcpy( tmp , buf , 8);
	memcpy( buf+0 , tmp+4 , 4 );
	memcpy( buf+4 , tmp+0 , 4 );
	
	return TRUE;
}
