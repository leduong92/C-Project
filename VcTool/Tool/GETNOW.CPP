//=======================================================================================================
//
//        《 汎用 》
//
//        現時刻取得プログラム
//        File name : GETNOW.C
//        技術本部  生産技術部
//        作成者 ： 小林
//        作成日 ： 1996.1.11
//		  修正日 ： 1996.5.07 take
//					Ｃ５でのワーニング（pointer mismatch）を削除
//				 ： 1996.12.09 Koba
//					ホスト送信形式(?YYMMDDHHMMSS)対応
//				 ： 1999.04.08 Coba
//					ホスト送信形式での致命的バグの修正 1 → '1'
//					2008.04.03 ﾏﾂﾀﾞ
//					CvDateTimeを追加
//					get_yobiを追加 2008.08.18 ﾏﾂﾀﾞ
//=======================================================================================================


#include "windows.h"
#include "getnow.h"

int UruuCheck(int year);

/*-----------------------------------------------------------------------------
 * 	関数名:		void	get_nowtime(char *buf,short mode, short plus )
 *
 * 	概要　:		現在の時刻を指定した文字列型で取得する。
 * 	引数１:		格納するポインタ
 *  引数２:     取得モード
 *  引数３：　　加える日数（日）
 * 	返し値:		なし
 *---------------------------------------------------------------------------*/
void	get_nowtime( char *buf, short mode, short plus )
{
	time_t 	ltime;
	struct	tm	*nowtime;
    char dummy[20];
	TMSTRCT *outTime;

    memset( dummy, 0 , sizeof(dummy));

	time(&ltime);
	ltime += (time_t)(plus)*24*60*60;
	nowtime=localtime(&ltime);

    if(nowtime->tm_year >= 95){
       nowtime->tm_year += 1900;
    }
    else{
       nowtime->tm_year += 2000;
    }

	sprintf(dummy,"%04d%02d%02d%02d%02d%02d", nowtime->tm_year,
                      nowtime->tm_mon+1,nowtime->tm_mday,nowtime->tm_hour,
                                   nowtime->tm_min,nowtime->tm_sec	);

    switch( mode){
       case HDATEL:
          memcpy( buf, dummy, HDATEL );
          break;

       case LDATEL:
          memcpy( buf, dummy, LDATEL );
          break;

       case MDATEL:
          memcpy( buf, dummy, MDATEL );
          break;

       case SDATEL:
          memcpy( buf, dummy, SDATEL );
          break;

       case HOST_L:
		  if( memcmp( &dummy[2],"93", 2) > 0 )
				buf[0]='0';
		  else
				buf[0]='1';
		  memcpy( &buf[1],&dummy[2],HOST_L);
		  break;

		case TIMEST:
			outTime = (TMSTRCT*)buf;
			outTime->year = nowtime->tm_year;
			outTime->month = nowtime->tm_mon+1;
			outTime->day = nowtime->tm_mday;
			outTime->hour = nowtime->tm_hour;
			outTime->min = nowtime->tm_min;
			outTime->sec = nowtime->tm_sec;
          break;
	   default:
          break;
   }

}

// 日数計算
void Calctime( char *buf,char *date, short plus )
{
	time_t 	ltime=0;
	struct	tm	nowtime,*newtime;
    char dummy[20];

	memset( &nowtime,0,sizeof(nowtime));

	// 基準日を経過秒にする

	// 年
    memset( dummy, 0 , sizeof(dummy));
	memcpy(dummy,date,4);
	nowtime.tm_year = atol(dummy)-1900;

	// 月
    memset( dummy, 0 , sizeof(dummy));
	memcpy(dummy,&date[4],2);
	nowtime.tm_mon = atol(dummy)-1;

	// 日
    memset( dummy, 0 , sizeof(dummy));
	memcpy(dummy,&date[6],2);
	nowtime.tm_mday=atol(dummy);

	ltime = mktime(&nowtime);
	ltime += (time_t)(plus)*24*60*60;

	newtime=localtime(&ltime);
    if(newtime->tm_year >= 95){
       newtime->tm_year += 1900;
    }
    else{
       newtime->tm_year += 2000;
    }

	sprintf(dummy,"%04d%02d%02d%02d%02d%02d", newtime->tm_year,
                      newtime->tm_mon+1,newtime->tm_mday,newtime->tm_hour,
                                   newtime->tm_min,newtime->tm_sec	);

	memcpy( buf, dummy, 14 );

}

/*-----------------------------------------------------------------------------
 * 	関数名:		void	get_nowtime(char *buf,short mode, short plus )
 *
 * 	概要　:		現在の時刻を指定した文字列型で取得する。
 * 	引数１:		格納するポインタ
 *  引数２:     取得モード
 *  引数３：　　加える時間
 *  引数４：　　加える時間の単位
 * 	返し値:		なし
 *---------------------------------------------------------------------------*/
void	get_nowtime2( char *buf, short mode, long plus ,int tani)
{
	time_t 	ltime;
	struct	tm	*nowtime;
    char dummy[20];

    memset( dummy, 0 , sizeof(dummy));

	time(&ltime);

	// 時間の足し込み
	switch( tani ){
		case MD_SEC:
			ltime += (time_t)plus;
			break;
		case MD_MIN :
			ltime += (time_t)(plus)*60;
			break;
		case MD_HOUR:
			ltime += (time_t)(plus)*60*60;
			break;
		case MD_DAY:
			ltime += (time_t)(plus)*24*60*60;
			break;
		default:
			break;
		
	}

	nowtime=localtime(&ltime);

    if(nowtime->tm_year >= 95){
       nowtime->tm_year += 1900;
    }
    else{
       nowtime->tm_year += 2000;
    }

	sprintf(dummy,"%04d%02d%02d%02d%02d%02d", nowtime->tm_year,
                      nowtime->tm_mon+1,nowtime->tm_mday,nowtime->tm_hour,
                                   nowtime->tm_min,nowtime->tm_sec	);

    switch( mode){
       case HDATEL:
          memcpy( buf, dummy, HDATEL );
          break;

       case LDATEL:
          memcpy( buf, dummy, LDATEL );
          break;

       case MDATEL:
          memcpy( buf, dummy, MDATEL );
          break;

       case SDATEL:
          memcpy( buf, dummy, SDATEL );
          break;

       case HOST_L:
		  if( memcmp( &dummy[2],"93", 2) > 0 )
				buf[0]='0';
		  else
				buf[0]='1';
		  memcpy( &buf[1],&dummy[2],HOST_L);
		  break;

	   default:
          break;
   }

}

/*-----------------------------------------------------------------------------
 * 	関数名:		void NglogAdd(char *prgname ,char*  mode, short code )
 *
 * 	概要　:		エラーメッセージを今日の日付のエラーﾌｧｲﾙに書き込む。
 * 	引数１:		エラーを引き起こしたプログラム名
 *  引数２:     メッセージ
 *  引数３：　　エラーコード（コードが無いときは 0 を送ると非表示になります）
 *  引数４：　　保存ディレクトリ。省略可
 * 	返し値:		なし
 *---------------------------------------------------------------------------*/
void NglogAdd(char *prgname, char *msg, short code,char* dir)
{
	char filename[MAX_PATH+1];
	char now[HDATEL+1];
	char buf[24];
	FILE *fp;
	WIN32_FIND_DATA fd;
	HANDLE hFind;

   // ファイル名のセット（ファイル名は今日の日付.err）
   memset(now,      0 ,sizeof(now));
   get_nowtime( now,SDATEL,0);

	// ディレクトリ指定なし
	if( dir==NULL){
		// ﾃﾞｨﾚｸﾄﾘを検索し、無ければ作成する
		strcpy( filename,".\\log\0\0");
		memset( &fd, 0, sizeof(fd) );
		fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
		hFind = FindFirstFile(filename,&fd);
		// 無い場合はディレクトリ作成
		if( hFind == INVALID_HANDLE_VALUE){
			if(!CreateDirectory(filename,NULL)){
				FindClose(hFind);
				return;
			}
		}

		FindClose(hFind);
		sprintf(filename, ".\\log\\%s.err",now);
	}
	else{
		sprintf(filename, "%s\\%s.err",dir,now);
	}

   // ファイルオープン
   if( (fp = fopen( filename,"ab")) == NULL ){
//      printf("\nエラーファイルオープン失敗！！！");
      return;
   }

   // エラー内容書き込み
   memset(now, 0 ,sizeof(now));        // 発生日時
   memset(buf, 0 ,sizeof(buf));
   get_nowtime( now,HDATEL,0);
   memcpy(buf,&now[2],2);
   strcat(buf,"/");
   memcpy(&buf[3],&now[4],2);
   strcat(buf,"/");
   memcpy(&buf[6],&now[6],2);
   strcat(buf," ");
   memcpy(&buf[9],&now[8],2);
   strcat(buf,":");
   memcpy(&buf[12],&now[10],2);
   strcat(buf,":");
   memcpy(&buf[15],&now[12],2);
   fprintf(fp, "%s:",buf);

   fprintf(fp, "%s:",prgname);        // プログラム名
   fprintf(fp, "%s",msg);
   if(code)
	   fprintf(fp,":err=%d\r\n",code);	// 2010.11.03 coba \r追加
   else
	   fprintf(fp, "\r\n");				// 2010.11.03 coba \r追加

   fclose(fp);
}

// 日数計算
/*-----------------------------------------------------------------------------
 * 	関数名:		void Calctime( char *buf,char *date, short plus ,short plus)
 *
 * 	概要　:		現在の時刻を指定した文字列型で取得する。
 * 	引数１:		格納するポインタ
 *  引数２:     基準日（YYYYMMDDHHMMSS）
 *  引数３：　　加える時間
 *  引数４：　　加える時間の単位
 * 	返し値:		なし
 *---------------------------------------------------------------------------*/
void Calctime( char *buf,char *date, int plus ,short tani)
{
	time_t 	ltime=0;
	struct	tm	nowtime,*newtime;
    char dummy[20];

	memset( &nowtime,0,sizeof(nowtime));

	// 基準日を経過秒にする

	// 年
    memset( dummy, 0 , sizeof(dummy));
	memcpy(dummy,date,4);
	nowtime.tm_year = atol(dummy)-1900;

	// 月
	memcpy(dummy,&date[4],2);
	dummy[2] = 0;
	nowtime.tm_mon = atol(dummy)-1;

	// 日
	memcpy(dummy,&date[6],2);
	dummy[2] = 0;
	nowtime.tm_mday=atol(dummy);

	// 時
	memcpy(dummy,&date[8],2);
	dummy[2] = 0;
	nowtime.tm_hour=atol(dummy);

	// 分
	memcpy(dummy,&date[10],2);
	dummy[2] = 0;
	nowtime.tm_min=atol(dummy);

	// 秒
	memcpy(dummy,&date[12],2);
	dummy[2] = 0;
	nowtime.tm_sec=atol(dummy);

	// tm->time_t
	ltime = mktime(&nowtime);

	// 日数をとる
	// 時間の足し込み
	switch( tani ){
		case MD_SEC:
			ltime += (time_t)plus;
			break;
		case MD_MIN :
			ltime += (time_t)(plus)*60;
			break;
		case MD_HOUR:
			ltime += (time_t)(plus)*60*60;
			break;
		case MD_DAY:
			ltime += (time_t)(plus)*24*60*60;
			break;
		default:
			break;
		
	}

	// time_t -> tm
	newtime=localtime(&ltime);
    if(newtime->tm_year >= 95){
       newtime->tm_year += 1900;
    }
    else{
       newtime->tm_year += 2000;
    }

	sprintf(dummy,"%04d%02d%02d%02d%02d%02d", newtime->tm_year,
                      newtime->tm_mon+1,newtime->tm_mday,newtime->tm_hour,
                                   newtime->tm_min,newtime->tm_sec	);

	memcpy( buf, dummy, 14 );

}

//---------------------------------------------------------------------------------------------------------------------
//	void CvDateTime(char *src,char *dest,int mode)
//	機能　：20080305161102などの文字列に '/' や、':'を入れた形式に変換
//	引数１：変換元になる文字列
//	引数２：変換後、格納するバッファ
//	引数３：各モード
//	2008.04.03 ﾏﾂﾀﾞ
//---------------------------------------------------------------------------------------------------------------------
void CvDateTime(char *src,char *dest,int mode)
{
	//時刻型
	if( mode == CVMODE_TIME ){
		if( strlen(src) < 6 ) return;
		memcpy(dest,src,2);
		memcpy(dest+2,":",1);
		memcpy(dest+3,src+2,2);
		memcpy(dest+5,":",1);
		memcpy(dest+6,src+4,2);
	}

	//日付型
	if( mode == CVMODE_DATE ){
		if( strlen(src) < 8 ) return;
		memcpy(dest,src,4);
		memcpy(dest+4,"/",1);
		memcpy(dest+5,src+4,2);
		memcpy(dest+7,"/",1);
		memcpy(dest+8,src+6,2);
	}
	
	//日付時刻型
	if( mode == CVMODE_DATETIME ){
		if( strlen(src) < 14 ) return;
		memcpy(dest,src,4);
		memcpy(dest+4,"/",1);
		memcpy(dest+5,src+4,2);
		memcpy(dest+7,"/",1);
		memcpy(dest+8,src+6,2);
		memcpy(dest+10," ",1);
		memcpy(dest+11,src+8,2);
		memcpy(dest+13,":",1);
		memcpy(dest+14,src+10,2);
		memcpy(dest+16,":",1);
		memcpy(dest+17,src+12,2);
	}
}
//---------------------------------------------------------------------------------------------------------------------
//	int get_yobi(char *date,char *dest)
//	機能　：曜日を取得する
//	引数１：曜日を算出する日
//	戻り値：曜日を表す数値 0:日曜〜6:土曜日
//	○曜日を表示したい場合には、YOBI_TBLJP[]に戻り値を入れてください
//	2008.08.18 ﾏﾂﾀﾞ
//---------------------------------------------------------------------------------------------------------------------
int get_yobi(char *date)
{
	int y,m,d,yobi;
	long count;
	char buf[20];
	int     MTBL[12]=  { 0,31,59,90,120,151,181,212,243,273,304,334 };

	//8バイトは必須
	if( strlen(date) < 8 )return -1;
	
	memcpy(buf,date,4);buf[4]=0;
	y=atoi(buf);
	memcpy(buf,date+4,2);buf[2]=0;
	m=atoi(buf);
	memcpy(buf,date+6,2);buf[2]=0;
	d=atoi(buf);

	//西暦１年１月１日からの通算日数を調べる
    count=  (y-1)*365L;            //年*３６５
    count+= (y/4L - y/100L + y/400L + MTBL[m-1] + d);
    if( m<3 && UruuCheck(y) )  count--;

	yobi= count%7L;
	return yobi;
}
//---------------------------------------------------------------------------------------------------------------------
//	int uruu(int year)
//	うるう年ﾁｪｯｸ
//---------------------------------------------------------------------------------------------------------------------
int UruuCheck(int year)
{
	if (year%400L==0L)  return(1);
	if(year%100L==0L)  return(0);
	if(year%4L==0L)    return(1);
	return(0);
}
//---------------------------------------------------------------------------------------------------------------------
//	int check_date(char* date)
//	機能　：日付の妥当性チェック
//	引数１：チェックする日付
//	戻り値：０：正常な日付 それ以外：不正な日付
//---------------------------------------------------------------------------------------------------------------------
int check_date(char* date)
{
	char buf[50];

	//桁足らず
	if( strlen(date) < 8 ) return -1;

	int y,m,d;
	memcpy(buf,date,4);buf[4]=0;
	y = atoi(buf);
	memcpy(buf,date+4,2);buf[2]=0;
	m = atoi(buf);
	memcpy(buf,date+6,2);buf[2]=0;
	d = atoi(buf);

	if( m < 1 || m > 12 ) return -2;//月が不正

	int nUruu = 0;
	int nMaxDay;

	//閏年の確認
	nUruu = UruuCheck(y);
	//その月の最大日付を決定
	switch(m) {
		case 2:nMaxDay = 28+nUruu;
			break;
		case 4:
		case 6:
		case 9:
		case 11: nMaxDay = 30; break;
		default: nMaxDay = 31; break;
	}
	if( d > nMaxDay ) return -3;	//日付が不正

	return 0;	//正常
}

//---------------------------------------------------------------------------------------------------------------------
// 2013.08.06 coba
// int SubDays(int *days,char* date1,char* date2)
// 日付の引き算(日) date1-date2
// 引数2-引数1の結果を引数1にセット
// 引数１:日付の差(日)
// 引数２:日付1
// 引数３:日付2
// 戻り値:0=OK
//---------------------------------------------------------------------------------------------------------------------
int SubDays(int *days,const char* date1,const char* date2)
{
	int y,m,d;
	long count1,count2;
	char buf[20];
	int     MTBL[12]=  { 0,31,59,90,120,151,181,212,243,273,304,334 };

	if( strlen(date1) < 8 || strlen(date2) < 8 ) return(-1);

	//西暦１年１月１日からの通算日数を調べる:date1
	memcpy(buf,date1,4);buf[4]=0;
	y=atoi(buf);
	memcpy(buf,date1+4,2);buf[2]=0;
	m=atoi(buf);
	memcpy(buf,date1+6,2);buf[2]=0;
	d=atoi(buf);
    count1=  (y-1)*365L;            //年*３６５
    count1+= (y/4L - y/100L + y/400L + MTBL[m-1] + d);
    if( m<3 && UruuCheck(y) )  count1--;

	//西暦１年１月１日からの通算日数を調べる:date2
	memcpy(buf,date2,4);buf[4]=0;
	y=atoi(buf);
	memcpy(buf,date2+4,2);buf[2]=0;
	m=atoi(buf);
	memcpy(buf,date2+6,2);buf[2]=0;
	d=atoi(buf);
    count2=  (y-1)*365L;            //年*３６５
    count2+= (y/4L - y/100L + y/400L + MTBL[m-1] + d);
    if( m<3 && UruuCheck(y) )  count2--;
//printf("%d,%d\n",count1,count2);
	// 差の日数
	*days=(int)(count1-count2);

	return(0);
}

//---------------------------------------------------------------------------------------------------------------------
// 2013.08.06 coba
// int SubDays(int *days,char* date1,char* date2)
// 日付の引き算(秒) date1-date2
// 引数2-引数1の結果を引数1にセット
// 引数１:日付の差(秒)
// 引数２:日付1
// 引数３:日付2
// 戻り値:0=OK
//---------------------------------------------------------------------------------------------------------------------
int SubSeconds(long* seconds,const char* date1,const char* date2)
{
	int y,m,d;
	int hour, minit, second;
	long day1, day2, days;
	long time1, time2;
	//long count1,count2;
	char buf[20];
	int     MTBL[12]=  { 0,31,59,90,120,151,181,212,243,273,304,334 };

	if( strlen(date1) < 14 || strlen(date2) < 14 ) 
		return(-1);

	//西暦１年１月１日からの通算日数を調べる:date1
	memcpy(buf,date1,4);buf[4]=0;
	y=atoi(buf);
	memcpy(buf,date1+4,2);buf[2]=0;
	m=atoi(buf);
	memcpy(buf,date1+6,2);buf[2]=0;
	d=atoi(buf);
    day1=  (y-1)*365L;            //年*３６５
    day1+= (y/4L - y/100L + y/400L + MTBL[m-1] + d);
    if( m<3 && UruuCheck(y) )  
		day1--;

	//西暦１年１月１日からの通算日数を調べる:date2
	memcpy(buf,date2,4);buf[4]=0;
	y=atoi(buf);
	memcpy(buf,date2+4,2);buf[2]=0;
	m=atoi(buf);
	memcpy(buf,date2+6,2);buf[2]=0;
	d=atoi(buf);
    day2=  (y-1)*365L;            //年*３６５
    day2+= (y/4L - y/100L + y/400L + MTBL[m-1] + d);
    if( m<3 && UruuCheck(y) )  
		day2--;

	//日付の計算
	days = day1 - day2;

	//hh:mm:ssを秒に変換する:date1
	memcpy(buf,date1+8,2);buf[2]=0;
	hour=atoi(buf);
	memcpy(buf,date1+10,2);buf[2]=0;
	minit=atoi(buf);
	memcpy(buf,date1+12,2);buf[2]=0;
	second=atoi(buf);
	time1 = hour*60*60 + minit*60 + second;

	//hh:mm:ssを秒に変換する:date2
	memcpy(buf,date2+8,2);buf[2]=0;
	hour=atoi(buf);
	memcpy(buf,date2+10,2);buf[2]=0;
	minit=atoi(buf);
	memcpy(buf,date2+12,2);buf[2]=0;
	second=atoi(buf);
	time2 = hour*3600 + minit*60 + second;

	//秒数を計算
	*seconds = days*24*60*60 +(time1 - time2);

	return(0);
}
//---------------------------------------------------------------------------------------------------------------------
//	void CvDateTimeUS(char *src,char *dest,int mode)
//	機能　：20080305161102などの文字列に '/' や、':'を入れた形式に変換:US版 DD-MM-YYYY
//	引数１：変換元になる文字列
//	引数２：変換後、格納するバッファ
//	引数３：各モード
//	2015.05.09 coba
//---------------------------------------------------------------------------------------------------------------------
void CvDateTimeUS(char *src,char *dest,int mode)
{
	//時刻型
	if( mode == CVMODE_TIME ){
		if( strlen(src) < 6 ) return;
		memcpy(dest,src,2);
		memcpy(dest+2,":",1);
		memcpy(dest+3,src+2,2);
		memcpy(dest+5,":",1);
		memcpy(dest+6,src+4,2);
	}

	//日付型
	if( mode == CVMODE_DATE ){
		if( strlen(src) < 8 ) return;
		memcpy(dest,src+6,2);
		memcpy(dest+2,"-",1);
		memcpy(dest+3,src+4,2);
		memcpy(dest+5,"-",1);
		memcpy(dest+6,src,4);
	}
	
	//日付時刻型
	if( mode == CVMODE_DATETIME ){
		if( strlen(src) < 14 ) return;
		memcpy(dest,src+6,2);
		memcpy(dest+2,"-",1);
		memcpy(dest+3,src+4,2);
		memcpy(dest+5,"-",1);
		memcpy(dest+6,src,4);
		memcpy(dest+10," ",1);
		memcpy(dest+11,src+8,2);
		memcpy(dest+13,":",1);
		memcpy(dest+14,src+10,2);
		memcpy(dest+16,":",1);
		memcpy(dest+17,src+12,2);
	}
}
